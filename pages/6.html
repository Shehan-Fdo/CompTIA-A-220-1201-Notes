<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>Introduction to IP, TCP, and UDP - A+ Core 1 (2.1)</title><link rel="stylesheet" href="../style.css"></head><body><div class="container"><div class="header"><h1>Introduction to IP, TCP, and UDP</h1><p>CompTIA A+ 220-1201 - Core 1 | Lesson 2.1</p></div><div class="section"><h2>Introduction to IP</h2><ul><li>IP (<strong>Internet Protocol</strong>) is the foundation for modern networks, enabling data transfer between devices.</li><li>IP operates independently of the physical network type (e.g., <code>Ethernet</code>, <code>wireless</code>, <code>DSL</code>).</li><li>IP focuses on the <strong>content</strong> of packets, not the transportation method.</li><li>Analogy: IP acts like a <strong>truck</strong> carrying data (<strong>boxes</strong>) across a network (<strong>road</strong>).</li><li>Key concept: <strong>Encapsulation</strong> and <strong>decapsulation</strong>—nesting data within layers (e.g., <code>HTTP → TCP → IP → Ethernet</code>).</li></ul></div><div class="section"><h2>Ethernet Frames and IP Packets</h2><ul><li>An <code>Ethernet frame</code> contains:
<ul><li><strong>Header</strong>: Marks the start of data.</li><li><strong>Payload</strong>: Contains the actual data (e.g., IP packet).</li><li><strong>Trailer</strong>: Marks the end of data.</li></ul></li><li>An <code>IP packet</code> within an Ethernet frame includes:
<ul><li><strong>IP header</strong>: Metadata for routing.</li><li><strong>IP payload</strong>: Contains higher-layer protocols (e.g., <code>TCP</code>, <code>UDP</code>).</li></ul></li><li>Example breakdown:
<ul><li><code>Ethernet → IP → TCP → HTTP</code> (for web traffic).</li></ul></li></ul></div><div class="section"><h2>TCP vs. UDP</h2><ul><li>Both are <strong>Layer 4 protocols</strong> (OSI model) for transporting data.</li><li><strong>Multiplexing</strong>: Enable simultaneous communication between multiple devices/services.</li><li><strong>TCP (Transmission Control Protocol)</strong>:
<ul><li><strong>Connection-oriented</strong>: Formal setup/teardown (like a phone call).</li><li><strong>Reliable delivery</strong>:
<ul><li><strong>Acknowledgments</strong>: Receiver confirms data arrival.</li><li><strong>Error recovery</strong>: Retransmits corrupted/lost data.</li><li><strong>Flow control</strong>: Adjusts data speed based on receiver capacity.</li></ul></li><li>Used for: <code>HTTPS</code>, <code>SSH</code>, <code>email (SMTP/IMAP)</code>.</li></ul></li><li><strong>UDP (User Datagram Protocol)</strong>:
<ul><li><strong>Connectionless</strong>: No setup/teardown (fire-and-forget).</li><li><strong>Unreliable delivery</strong>:
<ul><li>No acknowledgments or retransmissions.</li><li>No flow control.</li></ul></li><li><strong>Low overhead</strong>: Faster for real-time applications.</li><li>Used for: <code>VoIP</code>, <code>video streaming</code>, <code>DHCP</code>, <code>TFTP</code>.</li><li>Applications handle reliability (e.g., VoIP asks for retransmission at the app level).</li></ul></li></ul></div><div class="section"><h2>Ports and Services</h2><ul><li><strong>Port numbers</strong>: Direct data to specific services/applications on a device (like room labels in a house).</li><li>Range: <code>0–65,535</code> for both TCP and UDP (separate pools).</li><li><strong>Well-known (non-ephemeral) ports</strong>:
<ul><li>Permanent ports for standard services (e.g., <code>80</code> for HTTP, <code>443</code> for HTTPS).</li><li>Range: Typically <code>0–1023</code>.</li></ul></li><li><strong>Ephemeral ports</strong>:
<ul><li>Temporary ports for client-side communication.</li><li>Range: Typically <code>1024–65,535</code>.</li><li>Randomly assigned per session; reused after closure.</li></ul></li><li>Example communication:
<ul><li>Client (<code>10.0.0.1:54321</code>) → Server (<code>10.0.0.2:80</code>) for HTTP.</li><li>Server replies to client’s ephemeral port (<code>54321</code>).</li></ul></li><li>Ports are <strong>not a security feature</strong>—they’re public by design.</li></ul></div><div class="section"><h2>Data Flow Example</h2><ul><li>Scenario: Client (<code>10.0.0.1</code>) communicates with a multi-service server (<code>10.0.0.2</code>).</li><li>Services on server:
<ul><li>Web server: <code>TCP/80</code> (HTTP).</li><li>VoIP server: <code>UDP/5004</code>.</li><li>Email server: <code>TCP/143</code> (IMAP).</li></ul></li><li>Key observations:
<ul><li>Same <code>source IP</code> and <code>destination IP</code> for all flows.</li><li>Different <code>destination ports</code> (well-known) and <code>source ports</code> (ephemeral).</li><li>Protocol depends on service (<code>TCP</code> for reliability, <code>UDP</code> for speed).</li></ul></li><li>Packet structure:
<ul><li><code>Ethernet Header → IP Header → TCP/UDP Header → Application Data (e.g., HTTP) → Ethernet Trailer</code>.</li></ul></li></ul></div><div class="section"><h2>Key Takeaways</h2><ul><li>IP is the <strong>backbone</strong> of networking, enabling data transfer across diverse physical networks.</li><li>TCP/UDP provide <strong>transport-layer</strong> services with trade-offs:
<ul><li>TCP: Reliable, ordered, slower (overhead).</li><li>UDP: Fast, unreliable, minimal overhead.</li></ul></li><li>Ports enable <strong>multiplexing</strong>, allowing multiple services to run on a single device.</li><li>Understanding encapsulation (<code>Ethernet → IP → TCP/UDP → Application</code>) is critical for troubleshooting.</li></ul></div><div class="footer"><p>End of Notes</p><div><a href="pages/2.0.html" class="nav-button">← Previous Lesson (2.0)</a><a href="pages/2.2.html" class="nav-button">Next Lesson (2.2) →</a></div></div></div></body></html>